-- Esquema opcional
create schema if not exists billing;

-- === Tabla customers ===
create table if not exists billing.customers (
  id          bigint generated always as identity primary key,
  name        varchar(150) not null,
  email       varchar(150),
  phone       varchar(50),
  created_at  timestamptz not null default now(),
  updated_at  timestamptz not null default now(),
  constraint uq_customers_email unique (email)
);

-- === Tabla products ===
create table if not exists billing.products (
  id          bigint generated always as identity primary key,
  name        varchar(150) not null,
  price       numeric(12,2)  not null check (price >= 0),
  sku         varchar(60),
  created_at  timestamptz not null default now(),
  updated_at  timestamptz not null default now(),
  constraint uq_products_sku unique (sku)
);

-- === Tabla invoices ===
create table if not exists billing.invoices (
  id            bigint generated always as identity primary key,
  customer_id   bigint not null,
  invoice_date  date   not null,
  currency      varchar(3) not null default 'USD',
  subtotal      numeric(14,2) not null default 0 check (subtotal >= 0),
  tax           numeric(14,2) not null default 0 check (tax >= 0),
  total         numeric(14,2) not null default 0 check (total >= 0),
  note          text,
  created_at    timestamptz not null default now(),
  updated_at    timestamptz not null default now(),

  constraint fk_invoices_customer_id
    foreign key (customer_id) references billing.customers(id)
);

create index if not exists idx_invoices_customer_id on billing.invoices(customer_id);
create index if not exists idx_invoices_invoice_date on billing.invoices(invoice_date);

-- === Tabla invoice_items ===
create table if not exists billing.invoice_items (
  id           bigint generated always as identity primary key,
  invoice_id   bigint not null,
  product_id   bigint not null,
  description  varchar(200),
  quantity     numeric(12,3) not null check (quantity > 0),
  unit_price   numeric(14,2) not null check (unit_price >= 0),
  line_total   numeric(14,2) not null generated always as
               (round(quantity * unit_price, 2)) stored,

  constraint fk_invoice_items_invoice_id
    foreign key (invoice_id) references billing.invoices(id) on delete cascade,

  constraint fk_invoice_items_product_id
    foreign key (product_id) references billing.products(id),

  constraint uq_invoice_items_invoice_product unique (invoice_id, product_id)
);

create index if not exists idx_invoice_items_invoice_id on billing.invoice_items(invoice_id);
create index if not exists idx_invoice_items_product_id on billing.invoice_items(product_id);

-- Trigger simple para updated_at
create or replace function billing.touch_updated_at()
returns trigger language plpgsql as $$
begin
  new.updated_at = now();
  return new;
end$$;

drop trigger if exists trg_customers_touch on billing.customers;
create trigger trg_customers_touch before update on billing.customers
for each row execute function billing.touch_updated_at();

drop trigger if exists trg_products_touch on billing.products;
create trigger trg_products_touch before update on billing.products
for each row execute function billing.touch_updated_at();

drop trigger if exists trg_invoices_touch on billing.invoices;
create trigger trg_invoices_touch before update on billing.invoices
for each row execute function billing.touch_updated_at();
